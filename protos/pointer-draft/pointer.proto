// Copyright (C) 2018 Storj Labs, Inc.
// See LICENSE for copying information.

syntax = "proto3";

import "google/protobuf/duration.proto";

// Whatever final version of the Pointer data structure that
// results from this will be integrated with the NetState
// proto file, so that Pointers are saved at given Paths
// (instead of the current SmallValue).

// ==============================================================
// ==============================================================
// VERSION 1 ====================================================

// Following this JSON draft, which is a conglomerate of the current properties
// for frame, bucket entry, pointer, and shard in service-storage-models:

// {
//   "user": "",
//   "name": "",
//   "created": "",
//   "index": "",
//   "hmac": {
//     "value": "",
//     "type": ""
//   },
//   "erasure": "",
//   "shards": [
//     {
//       "hash": "",
//       "parity": false,
//       "bytes": "",
//       "farmers": [
//         {
//           "begin": "",
//           "end": "",
//           "id": ""
//         }
//       ]
//     }
//   ]
// }

// Stream - not sure how to distinguish between remote or inline in this version
message Stream {
  string name = 1;
  // created is a date
  int64 created = 2;
  HMAC hmac = 3;
  ErasureType type = 4;
  // this transpiles to an array in Go
  repeated Segment segments = 5;
}

// HMAC and/or ErasureType could be enums
message HMAC {
  string value = 1;
  string type = 2;
}

message ErasureType {}

message Segment {
  string hash = 1;
  bool parity = 2;
  repeated Farmer farmers = 3;
}

message Farmer {
  int64 beginDate = 1;
  int64 endDate = 2;
  string ID = 3;
}

// ==============================================================
// ==============================================================
// VERSION 2 ====================================================

message RedundancyScheme {
  enum SchemeType {
    RS = 1;
  }
  SchemeType type = 1;

  // these values apply to RS encoding
  int64 required = 2;  // the minimum required for reconstruction
  int64 total = 3;     // the total amount of pieces we generated
  int64 repair_threshold = 4;  // the amount of pieces we need to drop to before triggering repair
  int64 success_threshold = 5;  // the amount of pieces we need to store to call it a success
}

message EncryptionScheme {
  enum EncryptionType {
    AESGCM = 1;
    SECRETBOX = 2;
    // we should only allow authenticated encryption schemes
  }
  EncryptionType type = 1;
  bytes encrypted_encryption_key = 2;
  bytes encrypted_starting_nonce = 3;
}

message RemotePiece {
  int64 piece_num = 1;
  string node_id = 2;
  int64 size = 3;  // full size, including merkle tree
}

message InlineSegment {
  bytes segment = 1;
}

message RemoteSegment {
  RedundancyScheme redundancy = 1;
  bytes piece_name = 2;
  repeated RemotePiece remote_pieces = 3;

  bytes merkle_root = 4; // the root hash of the hashes of all of these pieces
  int64 merkle_size = 5; // the amount of space the merkle tree takes up at the end of each chunk
}

message Pointer {
  enum DataType {
    INLINE = 1;
    REMOTE = 2;
  }
  DataType type = 1;
  EncryptionScheme encryption = 2;

  InlineSegment inline = 3;
  RemoteSegment remote = 4;
  int64 encrypted_unencrypted_size = 5;  // the size of the unencrypted object (!)

  google.protobuf.Duration expiration = 6;  // when the object expires
}