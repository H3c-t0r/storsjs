// Copyright (C) 2018 Storj Labs, Inc.
// See LICENSE for copying information.

syntax = "proto3";

import "google/protobuf/duration.proto";

message RedundancyScheme {
  enum SchemeType {
    RS = 1;
  }
  SchemeType type = 1;

  // these values apply to RS encoding
  int64 required = 2;  // the minimum required for reconstruction
  int64 total = 3;     // the total amount of pieces we generated
  int64 repair_threshold = 4;  // the amount of pieces we need to drop to before triggering repair
  int64 success_threshold = 5;  // the amount of pieces we need to store to call it a success
}

message EncryptionScheme {
  enum EncryptionType {
    AESGCM = 1;
    SECRETBOX = 2;
    // only allow authenticated encryption schemes
  }
  EncryptionType type = 1;
  bytes encrypted_encryption_key = 2;
  bytes encrypted_starting_nonce = 3;
}

message RemotePiece {
  int64 piece_num = 1;
  string node_id = 2;
  bool parity = 3;
  int64 size = 4;  // full size, including merkle tree
}

message InlineSegment {
  bytes segment = 1;
}

message RemoteSegment {
  RedundancyScheme redundancy = 1;
  bytes piece_name = 2;
  repeated RemotePiece remote_pieces = 3;
  repeated Farmer farmers = 4; // list of farmers

  bytes merkle_root = 5; // the root hash of the hashes of all of these pieces
  int64 merkle_size = 6; // the amount of space the merkle tree takes up at the end of each chunk
}

message Farmer {
  int64 beginDate = 1;
  int64 endDate = 2;
  string ID = 3;
}

message HMAC {
  string value = 1;
  string type = 2;
}

message Pointer {
  enum DataType {
    INLINE = 1;
    REMOTE = 2;
  }

  int64 created = 1; // date that pointer was created
  DataType type = 2;
  HMAC signature = 3;
  EncryptionScheme encryption = 4;

  InlineSegment inline = 5;
  RemoteSegment remote = 6;
  int64 encrypted_unencrypted_size = 7;  // the size of the unencrypted object (!)

  google.protobuf.Duration expiration = 8;  // when the object expires
}