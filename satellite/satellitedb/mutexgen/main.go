package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"sort"

	"golang.org/x/tools/go/packages"
)

// Methods is the common interface for types having methods.
type Methods interface {
	Method(i int) *types.Func
	NumMethods() int
}

// Code is the information for generating the code.
type Code struct {
	Config  *packages.Config
	Package string
	Roots   []*packages.Package

	Imports map[string]bool
	Ignore  map[string]bool

	Preamble bytes.Buffer
	Source   bytes.Buffer
}

func main() {
	flag.Parse()

	var code Code
	code.Imports = map[string]bool{}
	code.Ignore = map[string]bool{
		"error": true,
	}

	code.Config = &packages.Config{
		Mode: packages.LoadAllSyntax,
	}
	code.Package = "storj.io/storj/satellite"

	var err error
	code.Roots, err = packages.Load(code.Config, code.Package)
	if err != nil {
		panic(err)
	}

	code.PrintMutex()
	code.PrintPreamble()

	unformatted := code.Bytes()

	source, err := format.Source(unformatted)
	if err != nil {
		fmt.Println(string(unformatted))
		panic(err)
	}
	fmt.Println(string(source))
}

func (code *Code) Bytes() []byte {
	var all bytes.Buffer
	all.Write(code.Preamble.Bytes())
	all.Write(code.Source.Bytes())
	return all.Bytes()
}

func (code *Code) PrintPreamble() {
	w := &code.Preamble
	fmt.Fprintf(w, "// Code generated by mutexgen using 'go generate'. DO NOT EDIT. \n\n")
	fmt.Fprintf(w, "package satellitedb\n\n")
	fmt.Fprintf(w, "import (\n")

	var imports []string
	for imp := range code.Imports {
		imports = append(imports, imp)
	}
	sort.Strings(imports)
	for _, imp := range imports {
		fmt.Fprintf(w, "	%q\n", imp)
	}
	fmt.Fprintf(w, ")\n\n")
}

func (code *Code) PrintMutex() {
	code.Imports["sync"] = true
	code.Imports["storj.io/statellite"] = true

	code.Printf("// Mutex implements a locking wrapper around satellite.DB\n")
	code.Printf("type Mutex struct {\n")
	code.Printf("	mu sync.Mutex\n")
	code.Printf("	db satellite.DB\n")
	code.Printf("}\n\n")

	// find the satellite.DB type info
	dbObject := code.Roots[0].Types.Scope().Lookup("DB")
	methods := dbObject.Type().Underlying().(Methods)

	for i := 0; i < methods.NumMethods(); i++ {
		code.PrintLockedFunc("Mutex", methods.Method(i), true)
	}

	for i := 0; i < methods.NumMethods(); i++ {
		if !code.NeedsWrapper(methods.Method(i)) {
			continue
		}
		code.PrintWrapper(methods.Method(i))
	}
}

func (code *Code) Printf(format string, a ...interface{}) {
	fmt.Fprintf(&code.Source, format, a...)
}

func (code *Code) PrintSignature(sig *types.Signature) {
	code.PrintSignatureTuple(sig.Params(), true)
	if sig.Results().Len() > 0 {
		code.Printf(" ")
		code.PrintSignatureTuple(sig.Results(), false)
	}
}

func (code *Code) PrintSignatureTuple(tuple *types.Tuple, needsNames bool) {
	code.Printf("(")
	defer code.Printf(")")

	for i := 0; i < tuple.Len(); i++ {
		if i > 0 {
			code.Printf(", ")
		}

		param := tuple.At(i)
		if code.PrintName(tuple.At(i), i, needsNames) {
			code.Printf(" ")
		}
		code.PrintType(param.Type())
	}
}

func (code *Code) PrintCall(sig *types.Signature) {
	code.Printf("(")
	defer code.Printf(")")

	params := sig.Params()
	for i := 0; i < params.Len(); i++ {
		if i != 0 {
			code.Printf(", ")
		}
		code.PrintName(params.At(i), i, true)
	}
}

func (code *Code) PrintName(v *types.Var, index int, needsNames bool) bool {
	name := v.Name()
	if needsNames && name == "" {
		if v.Type().String() == "context.Context" {
			code.Printf("ctx")
			return true
		}
		code.Printf("a%d", index)
		return true
	}
	code.Printf("%s", name)
	return name != ""
}

func (code *Code) PrintType(t types.Type) {
	types.WriteType(&code.Source, t, (*types.Package).Name)
}

func (code *Code) IncludeImports(sig *types.Signature) {
	var tmp bytes.Buffer
	types.WriteSignature(&tmp, sig, func(p *types.Package) string {
		code.Imports[p.Path()] = true
		return p.Name()
	})
}

func (code *Code) NeedsWrapper(method *types.Func) bool {
	sig := method.Type().Underlying().(*types.Signature)
	return sig.Results().Len() == 1 && !code.Ignore[sig.Results().At(0).Type().String()]
}

func (code *Code) WrapperTypeName(method *types.Func) string {
	return "mu" + method.Name()
}

func (code *Code) PrintLockedFunc(receiverType string, method *types.Func, allowNesting bool) {
	sig := method.Type().Underlying().(*types.Signature)
	code.IncludeImports(sig)

	code.Printf("func (mu *%s) %s", receiverType, method.Name())
	code.PrintSignature(sig)
	code.Printf(" {\n")
	defer code.Printf("}\n\n")

	code.Printf("	mu.mu.Lock(); defer mu.mu.Unlock()\n")
	if code.NeedsWrapper(method) {
		code.Printf("	return &%s{&mu.mu, ", code.WrapperTypeName(method))
		code.Printf("mu.db.%s", method.Name())
		code.PrintCall(sig)
		code.Printf("}\n")
	} else {
		code.Printf("	return mu.db.%s", method.Name())
		code.PrintCall(sig)
		code.Printf("\n")
	}
}

func (code *Code) PrintWrapper(method *types.Func) {
	sig := method.Type().Underlying().(*types.Signature)
	results := sig.Results()
	result := results.At(0).Type()

	receiverType := code.WrapperTypeName(method)
	code.Printf("// %s implements locking wrapper for %s\n", receiverType, typeName(result))
	code.Printf("type %s struct {\n", receiverType)
	code.Printf("	mu *sync.Mutex\n")
	code.Printf("	db %s\n", typeName(result))
	code.Printf("}\n\n")

	methods := result.Underlying().(Methods)
	for i := 0; i < methods.NumMethods(); i++ {
		code.PrintLockedFunc(receiverType, methods.Method(i), false)
	}
}

func typeName(typ types.Type) string {
	var body bytes.Buffer
	types.WriteType(&body, typ, (*types.Package).Name)
	return body.String()
}
